<!doctype html>
<html lang="en" class="h-100">
	<head>
		<title>Board | {{board.name}}</title>
		<link rel="icon" type="image/svg+xml" href="/static/logo.svg">
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="">
		<meta name="keywords" content="">

		<!-- do not cache this page -->
		<meta http-equiv="cache-control" content="max-age=0"/>
		<meta http-equiv="cache-control" content="no-cache"/>
		<meta http-equiv="expires" content="0"/>
		<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
		<meta http-equiv="pragma" content="no-cache"/>

		<!-- Bootstrap -->
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

		<!-- socketIO -->
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.4.1/socket.io.min.js"></script>

		<!-- sortable -->
		<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>


		<style>
			html, body {
				height: 100%;
				overflow: hidden;
				margin: 0;
				padding: 0;
			}

			html {
				min-width: 150px;
			}

			body {
				color: lightgrey;
				margin: 0;
				padding: 0;
			}

			canvas {
				display: block;
				width: 100vw;
				height: 100vh;
				background-color: black;
			}

			#tools-toggle {
				opacity: 0.25;
				transition: opacity 0.4s ease;
			}

			#tools-toggle:hover {
				opacity: 1;
				transition: opacity 0.4s ease;
			}

			#tokenContainer {
				height: 100px;
				overflow-y: auto;
			}

			label {
				white-space: nowrap;
			}

			.accordion-button::after {
				filter: invert(1); /* Makes the dark chevron light */
			}

			.accordion-button:not(.collapsed)::after {
				filter: invert(1); /* Keeps it light when expanded too */
			}

			/* Optional: override accordion-button focus ring */
			.accordion-button:focus {
				box-shadow: none;
			}

			.accordion-button {
				background-color:rgb(55 58 60) !important
			}

			.token-img {
				width: 50px;
				height: 50px;
				cursor: pointer;
			}

			#icon-container img {
				width: 50px;
				height: 50px;
				cursor: pointer;
				margin: 4px;
			}

			.image-avatar {
				border-radius: 50%;
			}

			#map-select img {
				height: 50px;
				max-width: 200px;
			}

			#token-keybindings img {
				width: 50px;
				margin-right: 5px;
			}

			
			#map-select img {
				border: 1px solid rgb(193, 193, 193);
				border-radius: 5px;
			}

			#map-select .map-button-wrapper {
				position: relative;
				display: flex;
				width: 100%;
			}

			#map-select .main-btn {
				flex: 1;
				transition: all 0.3s ease;
				overflow: hidden;
			}

			#map-select .trash-btn {
				width: 0;
				opacity: 0;
				overflow: hidden;
				transition: all 0.3s ease;
				padding: 0;
				border: none;
			}

			#map-select .map-button-wrapper:hover .main-btn {
				flex: 0 1 calc(100% - 3rem); /* Shrink the main button */
			}

			#map-select .map-button-wrapper:hover .trash-btn {
				width: 3rem;
				opacity: 1;
				padding: 0.375rem 0.5rem;
			}



		</style>
	</head>
	<body>

		<div id="loading-overlay" class="position-fixed top-0 start-0 w-100 h-100 d-flex justify-content-center align-items-center bg-dark bg-opacity-75" style="z-index: 1050;">
			<div class="text-center text-white">
				<div class="spinner-border text-light mb-3" role="status">
					<span class="visually-hidden">Loading...</span>
				</div>
				<div id="loading-msg"></div>
			</div>
		</div>

		<canvas id="display">
			HTML Canvas element is not supported on your device and/or browser.
		</canvas>

		<button id="tools-toggle" class="btn position-fixed bottom-0 start-0 m-1" style="color: white" data-bs-toggle="offcanvas" data-bs-target="#offcanvas" aria-controls="offcanvas">
			<i class="bi bi-gear"></i>
		</button>

		<div id="controls" class="offcanvas offcanvas-start show bg-dark text-light" data-bs-scroll="true" data-bs-backdrop="false" tabindex="-1" id="offcanvas" aria-labelledby="offcanvasLabel">
			<div class="offcanvas-header border-bottom">
				<h5 class="offcanvas-title" id="offcanvasLabel">Controls</h5>
				<button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"></button>
			</div>
			<div class="offcanvas-body small p-0 d-flex flex-column h-100">

				<div class="accordion accordion-flush w-100 bg-dark text-light" id="accordionExample">
					<div class="accordion-item bg-dark text-light">
						<h2 class="accordion-header bg-dark text-light" id="headingOne">
							<button class="accordion-button collapsed bg-dark text-light" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
								Display
							</button>
						</h2>
						<div id="collapseOne" class="accordion-collapse collapse bg-dark text-light" aria-labelledby="headingOne" data-bs-parent="#accordionExample">
							<div class="accordion-body">
								<div class="mb-3">
									<label for="zoom-slider" class="form-label">Zoom</label>
									<input class="form-range" id="zoom-slider" type="range" value="0.5" min="0.01" max="4" step="0.01" oninput="set_zoom(this.value); update_display();">
								</div>
				
								<div class="mb-3">
									<label for="opacity-slider" class="form-label">Map Opacity</label>
									<input class="form-range" id="opacity-slider" type="range" value="1" min="0" max="1" step="0.01" oninput="map_opacity = this.value; update_display();">
								</div>
				
								<div class="row">
									<div class="col-sm-4 mb-3">
										<label for="grid-color" class="form-label">Grid</label>
										<input type="color" id="grid-color" value="#808080" oninput="update_color('grid', this.value);" class="form-control form-control-color w-100">
									</div>
				
									<div class="col-sm-4 mb-3">
										<label for="bg-color" class="form-label">Background</label>
										<input type="color" id="bg-color" value="#000000" oninput="update_color('background', this.value);" class="form-control form-control-color w-100">
									</div>
				
									<div class="col-sm-4 mb-3">
										<label for="table-color" class="form-label">Table</label>
										<input type="color" id="table-color" value="#000000" oninput="update_color('table', this.value);" class="form-control form-control-color w-100">
									</div>
				
									<div class="col-sm-4 mb-3">
										<label for="table-color" class="form-label">Selection</label>
										<input type="color" id="table-color" value="#00FFFF" oninput="update_color('selection', this.value);" class="form-control form-control-color w-100">
									</div>

									<div class="col-sm-4 mb-3">
										<label for="table-color" class="form-label">Mask</label>
										<input type="color" id="table-color" value="#000000" oninput="update_color('mask', this.value);" class="form-control form-control-color w-100">
									</div>

									{% if can_edit %}
									<div class="col-sm-4 mb-3">
										<label for="mask-opacity-slider" class="form-label">Mask Opacity</label>
										<input class="form-range" id="mask-opacity-slider" type="range" value="1" min="0" max="1" step="0.01" oninput="colors.maskOpacity = Number(this.value); update_display();">
									</div>
									{% endif %}

								</div>

								<hr class="bg-light">

								<div class="mb-3 d-flex align-items-center gap-3">
									<div class="w-50">
										<label for="distance-dropdown" class="form-label">Show Distance</label>
										<select id="distance-dropdown" class="form-select" onchange="update_distance_metric(this.value)">
											<option value="none" selected>No</option>
											<option value="L1">L1 (Manhattan)</option>
											<option value="L2">L2 (Euclidean)</option>
											<option value="Li">L&infin; (Chebyshev)</option>
											<option value="box">Box Counting</option>
										</select>
									</div>
									<div class="w-50">
										<label for="distance-multiplier" class="form-label">Multiplier</label>
										<input value="1" id="distance-multiplier" class="form-control" type="number" step="1" min="0" max="100" onchange="if (this.value) {this.value = Math.min(Math.max(0.1, this.value), 100);} else {this.value=1}; distance_multiplier=this.value; update_display();" />

									</div>
								</div>

							</div>
						</div>
					</div>
					
					<div id="map-controls" {% if not can_edit %} hidden {% endif %} class="accordion-item bg-dark text-light">
						<h2 class="accordion-header" id="headingTwo">
							<button class="accordion-button collapsed bg-dark text-light" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
								Map
							</button>
						</h2>
						<div id="collapseTwo" class="accordion-collapse collapse show" aria-labelledby="headingTwo" data-bs-parent="#accordionExample">
							<div class="accordion-body">
								<!-- <ul class="list-unstyled">
									<li id="map-select-li-064d7f5b-89f9-43ed-99cd-b30b53be1a8c" class="mb-2">
										<div class="d-flex map-button-wrapper align-items-stretch position-relative">
											<button class="main-btn btn flex-grow-1 d-flex align-items-center gap-3 btn-outline-primary">
												<i class="bi bi-eye" id="mask-eye-icon" style="width: 20px; visibility: visible;"></i>
												<span class="label-text">Mask</span>
											</button>
										</div>
									</li>
								</ul> -->
								<label class="form-label">Toggle and Reorder Map Layers</label>
								<ul id="map-select" class="list-unstyled"></ul>
								  
								  
								<hr class="bg-light">
								<form id="upload_map_form" class="mb-3">
									<label for="upload-map-file" class="form-label">Upload Map</label>
									<input type="hidden" name="board_method" value="upload_map" required>
									<input type="hidden" name="board_id" value="{{board.board_id}}" required>
									<input id="upload-map-file" type="file" class="form-control" name="image" required>
									<div class="d-flex align-items-column gap-3 mt-3">
										<input id="upload-map-name" type="text" placeholder="Name" class="form-control" name="name" required>
										<button type="submit" class="btn btn-outline-primary">Upload</button>
									</div>
								</form>

								<hr class="bg-light">

								<div class="row">
									<div class="mb-3 col-sm-6">
										<label for="num-columns" class="form-label d-block text-center">Columns</label>
										<input id="num-columns" class="form-control" type="number" step="1" min="1" max="200" onchange="if (this.value) {this.value = Math.min(Math.max(1, this.value), 200); change_num_squares('x', this.value)}" value="{{num_squares.x}}"/>
									</div>
				
									<div class="mb-3 col-sm-6">
										<label for="num-rows" class="form-label d-block text-center">Rows</label>
										<input id="num-rows" class="form-control" type="number" step="1" min="1" max="200" onchange="if (this.value) {this.value = Math.min(Math.max(1, this.value), 200); change_num_squares('y', this.value)}" value="{{num_squares.y}}"/>
									</div>
								</div>
								
								<hr class="bg-light">

								<div class="row">
									<div class="col-md-6 mb-3">
										<label for="offset-dropdown" class="form-label">Grid Offset</label>
										<select id="offset-dropdown" class="form-select" onchange="change_grid_offset(this.value)">
											<option id="offset-dropdown-None" value="None" {% if board.grid_offset.type == 'None' %}selected{% endif %}>None</option>
											<option id="offset-dropdown-Rows" value="Rows" {% if board.grid_offset.type == 'Rows' %}selected{% endif %}>Rows</option>
											<option id="offset-dropdown-Columns" value="Columns" {% if board.grid_offset.type == 'Columns' %}selected{% endif %}>Columns</option>
										</select>
									</div>

									<div class="w-50">
										<label for="offset-dropdown" class="form-label">Amount</label>
										<input id="offset-amount-slider" class="form-range" type="range" min="-1" max="1" step="0.05" value="{{board.grid_offset.amount}}" oninput="local_change_offset_amount(this.value)" onchange="change_grid_offset_amount(this.value)">
									</div>
								</div>

								<hr class="bg-light">
								
								<button type="submit" class="btn btn-danger w-100 my-2" onclick="reset()">Clear Board</button>

							</div>
						</div>
					</div>

					<div class="accordion-item bg-dark text-light">
						<h2 class="accordion-header" id="headingThree">
							<button class="accordion-button collapsed bg-dark text-light" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
								Key-Bindings
							</button>
						</h2>
						<div id="collapseThree" class="accordion-collapse collapse" aria-labelledby="headingThree" data-bs-parent="#accordionExample">
							<div class="accordion-body">
								<table class="table text-light small table-borderless">
									<tr>
										<th>Open Token Menu</th>
										<td>Tab</td>
									</tr>
									<tr>
										<th>Deselect Square</th>
										<td>Escape</td>
									</tr>
									<tr>
										<th>Place/Move Your Avatar</th>
										<td>Space</td>
									</tr>
									<tr>
										<th>Move Selected Square</th>
										<td>ArrowUp, ArrowDown, ArrowLeft, ArrowRight</td>
									</tr>
									<tr>
										<th>Clear Selected Square</th>
										<td>Delete or Backspace</td>
									</tr>
									<tr>
										<th>Toggle Control Panel</th>
										<td>S</td>
									</tr>
									<tr id="mask-info-tr" {% if not can_edit %} hidden {% endif %}>
										<th>Toggle Mask on Selected Square</th>
										<td>M</td>
									</tr>
								</table>
								<hr class="bg-light">
								<table id="token-keybindings" class="table text-light small table-borderless"></table>
							</div>
						</div>
					</div>

				
					<!-- <div class="accordion-item bg-dark text-light">
						<h2 class="accordion-header" id="headingFour">
							<button class="accordion-button collapsed bg-dark text-light" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFour" aria-expanded="false" aria-controls="collapseFour">
								Meta
							</button>
						</h2>
						<div id="collapseFour" class="accordion-collapse collapse" aria-labelledby="headingFour" data-bs-parent="#accordionExample">
							<div class="accordion-body">
								<button class="btn btn-warning w-100" onclick="leave(); location.href='/user'">Leave</button>
							</div>
						</div>
					</div> -->

				</div>
				
			</div>
		</div>

		<!-- <div id="menu" class="position-absolute bg-dark text-light border rounded shadow p-2" style="display:none; z-index:1060; width:200px;">
			<input type="text" id="tokenSearch" class="form-control form-control-sm mb-2 bg-light text-dark border-0 rounded" placeholder="Search...">
			<div id="icon-container" class="d-flex flex-wrap"></div>
		</div> -->
		<div id="menu" class="position-absolute bg-dark text-light border rounded shadow p-2" style="display:none; z-index:1060; width:200px; height: 250px">
			<!-- Smaller tab headers -->
			<ul class="nav nav-tabs mb-2" id="menuTabs" role="tablist" style="font-size: 0.85rem;">
			  <li class="nav-item" role="presentation">
				<button class="nav-link active py-1 px-2" id="place-tab" data-bs-toggle="tab" data-bs-target="#place" type="button" role="tab">Place</button>
			  </li>
			  <li id="aura-tab-li" class="nav-item" role="presentation">
				<button class="nav-link py-1 px-2" id="aura-tab" data-bs-toggle="tab" data-bs-target="#menu-aura" type="button" role="tab">Aura</button>
			  </li>
			</ul>
		  
			<!-- Tab contents -->
			<div class="tab-content">
			  <!-- Place tab -->
			  <div class="tab-pane fade show active" id="place" role="tabpanel" aria-labelledby="place-tab">
				<input type="text" id="tokenSearch" class="form-control form-control-sm mb-2 bg-light text-dark border-0 rounded" placeholder="Search...">
				<div id="icon-container" class="d-flex flex-wrap"></div>
			  </div>
		  
			  <!-- Aura tab -->
			  <div class="tab-pane fade" id="menu-aura" role="tabpanel" aria-labelledby="aura-tab">
				<form id="edit-aura-form" class="mt-3">
					<div class="form-check">
						<input class="form-check-input" type="checkbox" id="aura-toggle" onchange="update_aura()">
						<label class="form-check-label" for="aura-toggle">Enable</label>
					</div>
					<div class="d-flex">
						<div class="mb-2">
							<label for="aura-color" class="form-label">Color</label>
							<input type="color" id="aura-color" class="form-control form-control-color" value="#ffff00" onchange="update_aura()">
						</div>
						<div class="mb-2 mx-3">
							<label for="aura-size" class="form-label">Size</label>
							<input type="number" id="aura-size" class="form-control" min="1" step="1" value="1" onchange="update_aura()">
						</div>
					</div>
					<div class="mb-2">
						<label for="aura-shape" class="form-label">Shape (Distance Norm)</label>
						<select id="aura-shape" class="form-select" onchange="update_aura()">
							<option value="diamond">Diamond (L1)</option>
							<option value="circle" selected>Circle (L2)</option>
							<option value="square">Square (L&infin;)</option>
						</select>
					</div>
				
				
					
				</form>
			  </div>
			</div>
		  </div>
		  
	</body>



<script>
		const loading_overlay = document.getElementById('loading-overlay');
		var is_loading;
		function loading(bool, msg) {
			console.log('loading', bool, msg);
			is_loading = bool;
			if (bool) {
				loading_overlay.classList.remove('d-none');
			} else {
				loading_overlay.classList.add('d-none');
			}
			document.getElementById('loading-msg').innerHTML = msg || '';
		}

		const canvas = document.getElementById("display");
		const ctx = canvas.getContext("2d");
		const menu = document.getElementById("menu");


		var colors = {
			'grid': '#808080',
			'background': '#000000',
			'table': '#000000',
			'selection': '#00FFFF',
			'mask': '#000000',
			'maskOpacity': 1
		}
		var map_opacity = 1;
		var distance_metric = 'none';
		var distance_multiplier = 1;

		var zoom;
		var top_left_loc;

		var menu_open = false;
		

		function set_selected_square(rc) {
			if (rc) {
				selected_square = rc;
			} else {
				selected_square = null;
				
			}
			localStorage.setItem('selected_square+{{ board.board_id }}', JSON.stringify(selected_square));
				
		}

		var selected_square;

		
		

		function update_color(part, c) {
			colors[part] = c;
			update_display();
		}

		function update_distance_metric(val) {
			distance_metric = val;
			update_display();
		}

		function set_zoom(val) {
			zoom = val;
			square_size = zoom * canvas.width / num_squares.x;
			document.getElementById('zoom-slider').value = val;
			localStorage.setItem('zoom+{{ board.board_id }}', JSON.stringify(zoom));

		}
		
		function set_top_left(x, y) {
			top_left_loc = {x:x, y:y};
			localStorage.setItem('top_left_loc+{{ board.board_id }}', JSON.stringify(top_left_loc));
		}
		
		function show_menu() {

			if (!selected_square) return;

			// Compute the screen position of the selected square
			const x = top_left_loc.x + selected_square.c * square_size;
			const y = top_left_loc.y + selected_square.r * square_size;

			// Get canvas position relative to the page
			const rect = canvas.getBoundingClientRect();

			const menuX = rect.left + x;
			const menuY = rect.top + y - 10;

			menu_open = true;
			menu.style.display = 'block';
			menu.style.left = `${menuX}px`;
			menu.style.top = `${menuY - menu.offsetHeight}px`; // show *above* the square
		}

		function close_menu() {
			menu_open = false;
			menu.style.display = "none";
			document.getElementById('place-tab').classList.add('active');
			document.getElementById('place').classList.add('show', 'active');
			document.getElementById('aura-tab').classList.remove('active');
			document.getElementById('menu-aura').classList.remove('show', 'active');
		}


		function set_canvas_size() {
			let ratios = {
				x: top_left_loc.x / canvas.width,
				y: top_left_loc.y / canvas.height
			};
			let rect = canvas.getBoundingClientRect();
			canvas.width = rect.width;
			canvas.height = rect.height;
			set_top_left(
				canvas.width * ratios.x,
				canvas.height * ratios.y
			);
			square_size = zoom * canvas.width / num_squares.x;
		}

		window.onresize = (e) => {
			close_menu();
			set_canvas_size();
			update_display();
		};

		function event_to_coords(e) {
			let rect = canvas.getBoundingClientRect();
			let x = e.clientX - rect.left - top_left_loc.x;
			let y = e.clientY - rect.top - top_left_loc.y;
			return {x:x, y:y};
		}

		function on_grid(coords) {
			let {x, y} = coords;
			let r, c = 0;

			if (grid_offset.type == 'Rows') {
				r = Math.floor(y / square_size);
				c = Math.floor((x - (r % 2 == 0 ? square_size * grid_offset.amount : 0)) / square_size);
				if (r >= 0 && r < num_squares.y && c >= 0 && c < num_squares.x) {
					return {r:r, c:c};
				}
				return false;
			} else if (grid_offset.type == 'Columns') {
				c = Math.floor(x / square_size);
				r = Math.floor((y - (c % 2 == 0 ? square_size * grid_offset.amount : 0)) / square_size);
				if (r >= 0 && r < num_squares.y && c >= 0 && c < num_squares.x) {
					return {r:r, c:c};
				}
				return false
			}
			else {
				r = Math.floor(y / square_size);
				c = Math.floor(x / square_size);
				if (r >= 0 && r < num_squares.y && c >= 0 && c < num_squares.x) {
					return {r:r, c:c};
				}
				return false;
			}
			
			return false;
			
		}

		function handle_click(e) {
			let rc = on_grid(event_to_coords(e));
			set_selected_square(rc);
			update_aura_menu();
			close_menu();
			update_display()

		};

		var isDragging = false;
		let last_top_left_loc;
		let dragStart = { x: 0, y: 0 };
		let offset = { x: 0, y: 0 };

		canvas.onmousedown = (e) => {
			offset = { x: 0, y: 0 };
			last_top_left_loc = JSON.parse(JSON.stringify(top_left_loc));
			isDragging = true;
			dragStart.x = e.clientX - offset.x;
			dragStart.y = e.clientY - offset.y;
			close_menu();
		};

		canvas.onmousemove = (e) => {
			if (!isDragging) return;
			offset.x = (e.clientX - dragStart.x);
			offset.y = (e.clientY - dragStart.y);
			set_top_left(
				last_top_left_loc.x + offset.x,
				last_top_left_loc.y + offset.y
			)
			update_display();
		};

		canvas.onmouseup = (e) => {
		  const totalMove = Math.hypot(offset.x, offset.y);
		  isDragging = false;
		  if (totalMove < 2) {
		    handle_click(e);
		  }
		};

		canvas.onmouseleave = (e) => {
		  isDragging = false;
		};


		canvas.onwheel = (e) => {
		  if (e.ctrlKey || Math.abs(e.deltaY) < 1) {
		    e.preventDefault(); // Prevent default scroll behavior
			close_menu();
		    const zoomFactor = 1.05;
		    const zoomMultiplier = e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
		    const newZoom = zoom * zoomMultiplier;

		    const rect = canvas.getBoundingClientRect();
		    const cursorX = e.clientX - rect.left;
		    const cursorY = e.clientY - rect.top;

		    const deltaX = top_left_loc.x - cursorX;
		    const deltaY = top_left_loc.y - cursorY;

		    set_top_left(
				cursorX + deltaX * zoomMultiplier,
		      	cursorY + deltaY * zoomMultiplier
		  	);

		    set_zoom(newZoom);
		    update_display();
		  }
		};

		
		canvas.oncontextmenu = (e) => {
			e.preventDefault();			
		};



		document.onkeydown = (e) => {
			if (is_loading) return;

			if (e.shiftKey) {

				if (!selected_square) return;

				for (let token_id in icons['token']) {
					if (e.code === 'Key' + icons['token'][token_id].key && document.activeElement === document.body) {
						e.preventDefault();
						set_square(selected_square, {'content': {'id':token_id, 'type':'token'}});
						break;
					}
				}

				
				
			} else {

				if (e.code === 'Tab' && document.activeElement === document.body) {
					e.preventDefault();

					if (menu_open) {
						close_menu()
					} else {
						show_menu();
					}
				}
				
				if ((e.code === 'Delete' || e.code === 'Backspace') && document.activeElement === document.body) {
					e.preventDefault();

					if (!selected_square) return;

					set_square(selected_square, null);

				}

				if (e.code === 'Space' && document.activeElement === document.body) {
					e.preventDefault();
					if (!selected_square) return;

					set_square(selected_square, {
						'content': {'id':'{{user.user_id}}', 'type':'avatar'},
						'unique': 'avatar-' + '{{user.user_id}}'
					});
				}

				if (e.code === 'ArrowUp' && document.activeElement === document.body) {
					e.preventDefault();
					if (!selected_square) return;
					set_selected_square({r: (selected_square.r - 1 + num_squares.y) % num_squares.y, c: selected_square.c});
					close_menu();
					update_display()
				}

				if (e.code === 'ArrowDown' && document.activeElement === document.body) {
					e.preventDefault();
					if (!selected_square) return;
					set_selected_square({r: (selected_square.r + 1 + num_squares.y) % num_squares.y, c: selected_square.c});
					close_menu();
					update_display()
				}

				if (e.code === 'ArrowLeft' && document.activeElement === document.body) {
					e.preventDefault();
					if (!selected_square) return;
					set_selected_square({c: (selected_square.c - 1 + num_squares.x) % num_squares.x, r: selected_square.r});
					close_menu();
					update_display()
				}

				if (e.code === 'ArrowRight' && document.activeElement === document.body) {
					e.preventDefault();
					if (!selected_square) return;
					set_selected_square({c: (selected_square.c + 1 + num_squares.x) % num_squares.x, r: selected_square.r});
					close_menu();
					update_display()
				}

				if (e.code === 'Escape' && document.activeElement === document.body) {
					e.preventDefault();
					set_selected_square(null);
					update_display()
				}

				if (e.code === 'KeyS') {
					if (
						!['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName) &&
						!document.activeElement.isContentEditable
					) {
						e.preventDefault();
						const offcanvasEl = document.getElementById('controls'); // change to your ID
						const bsOffcanvas = bootstrap.Offcanvas.getOrCreateInstance(offcanvasEl);
						bsOffcanvas.toggle();
					}
				}

				if (e.code === 'KeyM' && document.activeElement === document.body) {
					e.preventDefault();
					if (!selected_square) return;
					if (!can_edit) return;
					loading(true, 'Setting Mask');
					toggle_mask(selected_square)
					
				}

			}


		};



		document.getElementById('tokenSearch').addEventListener('input', function () {
			const search = this.value.toLowerCase();
			const tokens = document.querySelectorAll('#icon-container .token-img');
			tokens.forEach(token => {
			  const name = token.dataset.name.toLowerCase();
			  token.style.display = name.includes(search) ? 'inline-block' : 'none';
			});
		});

	






		var board = JSON.parse('{{ board.get_grid_data()|tojson|safe }}');
		
		var icons = JSON.parse('{{ icons|tojson|safe }}');
		var icon_images = {};

		var can_edit = JSON.parse('{{ can_edit|tojson|safe }}');
		var super_secret = JSON.parse('{{ super_secret|tojson|safe }}');

		var maps = JSON.parse('{{ maps|tojson|safe }}');		
		var map_images = {};
		
		var visible_map_image = new Image();

		var num_squares;
		var square_size;
		
		var map_order;

		var grid_offset = JSON.parse('{{ grid_offset|tojson|safe }}');


		let saved_selected_square = localStorage.getItem('selected_square+{{ board.board_id }}');
		set_selected_square(saved_selected_square ? JSON.parse(saved_selected_square) : null);




		function make_map_DOM(map) {
			const img = new Image();
			map_images[map.image_id] = img;
			return new Promise((resolve, reject) => {
				img.onload = () => {
					console.log('Image loaded:', map.image_id);
					resolve();
				};
				img.onerror = (error) => {
					console.log('Image failed to load:', map.image_id, error);
					reject(error);
				};
				img.setAttribute('name', 'map-' + map.image_id);
				img.src = `/image/${map.image_id}`;
			});
		}

		function set_visible_map_image() {
			console.log("setting visible map image");
			return new Promise((resolve, reject) => {
				visible_map_image.onload = () => {
					console.log('Image loaded:', visible_map_image);
					resolve();
				};
				visible_map_image.onerror = (error) => {
					console.log('Image failed to load:', visible_map_image, error);
					reject(error);
				};
				visible_map_image.src = '/map/' + '{{ board.board_id }}?t=' + (new Date().getTime());
			});		
		}
		
		function make_icon_DOM(type, id) {
			const img = new Image();
			icon_images[type][id] = img;
			return new Promise((resolve, reject) => {
				img.onload = () => {
					console.log('Icon loaded:', type, id);
					resolve();
				};
				img.onerror = (error) => {
					console.log('Icon failed to load:', type, id, error);
					reject(error);
				};
				img.dataset.id = type + '-' + id;
				img.classList.add('image-' + type)
				img.src = `/${type}/${id}?t=${new Date().getTime()}`;
			});
		}

		function create_DOMs() {
			let imagePromises = [];

			for (let type in icons) {
				icon_images[type] = {};
				
				for (let id in icons[type]) {
					imagePromises.push(make_icon_DOM(type, id));
				}
			}

			if (can_edit || !super_secret) {
				for (let i = 0; i < maps.length; i++) {
					imagePromises.push(make_map_DOM(maps[i]));
				}
			}
			if (super_secret) {
				imagePromises.push(set_visible_map_image());
			}

			return Promise.all(imagePromises);
		}

		const icon_container = document.getElementById('icon-container');


		function build_menu_item(type, id) {
			return new Promise((resolve, reject) => {
				let img = icon_images[type][id].cloneNode(true);
				img.onload = () => {
					console.log('Icon loaded:', type, id);
					resolve();
				};
				img.onerror = (error) => {
					console.log('Icon failed to load:', type, id, error);
					reject(error);
				};
				img.classList.add('token-img');
				img.dataset.name = icons[type][id].name;
				img.addEventListener('click', () => {
					if (selected_square) {
						set_square(
							selected_square, 
							{
								content: {type: type, id: id},
								unique: type == 'avatar' ? 'avatar-' + id : false
							}
						);
					}
				});
				icon_container.appendChild(img);
			});
		}

		function build_menu() {
			let promises = [];
			for (const type in icons) {
				for (const id in icons[type]) {
					promises.push(build_menu_item(type, id));
				}
			}
			return Promise.all(promises);
		}

		function order_menu() {
			let icon_container = document.getElementById('icon-container');

			const images = Array.from(icon_container.children);

			// Sort according to rules
			images.sort((a, b) => {
				const aType = a.dataset.id.startsWith("avatar") ? 0 : 1;
				const bType = b.dataset.id.startsWith("avatar") ? 0 : 1;

				if (aType !== bType) return aType - bType;

				const aName = a.dataset.name || "";
				const bName = b.dataset.name || "";
				return aName.localeCompare(bName);
			});

			// Append sorted images back to container
			images.forEach(img => icon_container.appendChild(img));
		}

		function update_aura_menu() {
			if (!selected_square) return;
			let square_data = board[selected_square.r][selected_square.c];
			if (square_data.content) {
				document.getElementById('menu-aura').classList.remove('d-none');
				document.getElementById('aura-tab-li').classList.remove('d-none');
				if (square_data.content.aura) {
					document.getElementById('aura-toggle').checked = square_data.content.aura.enabled || false;
					document.getElementById('aura-color').value = square_data.content.aura.color || '#ffff00';
					document.getElementById('aura-size').value = square_data.content.aura.size || 1;
					document.getElementById('aura-shape').value = square_data.content.aura.shape || 'circle';
				} else {
					document.getElementById('aura-toggle').checked = false;
					document.getElementById('aura-color').value = '#ffff00';
					document.getElementById('aura-size').value = 1;
					document.getElementById('aura-shape').value = 'circle';
				}
			} else {
				document.getElementById('menu-aura').classList.add('d-none');
				document.getElementById('aura-tab-li').classList.add('d-none');
			}


			

		}


		const map_select = document.getElementById('map-select');

		function build_map_select_li(map) {
			return new Promise((resolve, reject) => {
				const li = document.createElement('li');
				li.setAttribute('id', 'map-select-li-' + map.image_id);
				li.className = 'mb-2';

				const wrapper = document.createElement('div');
				wrapper.className = 'd-flex map-button-wrapper align-items-stretch position-relative';

				const button = document.createElement('button');
				button.className = 'main-btn btn flex-grow-1 d-flex align-items-center gap-3 btn-outline-primary';
				
				const eye = document.createElement('i');
				eye.className = 'bi bi-eye';
				eye.style.width = "20px";
				eye.style.visibility = map.visible ? 'visible' : 'hidden';  
				eye.id = 'map-eye-icon-' + map.image_id;
				button.appendChild(eye);
				
				let img = map_images[map.image_id].cloneNode(true);
				img.onload = () => {
					console.log('Image loaded:', map.image_id);
					resolve();
				};
				img.onerror = (error) => {
					console.log('Image failed to load:', map.image_id, error);
					reject(error);
				};
				button.appendChild(img);			

				const label = document.createElement('span');
				label.className = 'label-text';
				label.textContent = map.name;
				button.appendChild(label);

				const trashBtn = document.createElement('button');
				trashBtn.className = 'trash-btn btn text-danger d-flex align-items-center justify-content-center';
				trashBtn.innerHTML = '<i class="bi bi-trash"></i>';
				trashBtn.onclick = () => {
					loading(true, 'Deleting map');
					navigator.sendBeacon(
						'/board_access',
						new Blob(
							[
								JSON.stringify({
									image_id: map.image_id,
									board_id: '{{board.board_id}}',
									board_method: 'delete_map',
								}),
							],
							{ type: 'application/json' }
						)
					);
				};

				button.onclick = function () {
					loading(true, 'Changing map visibility');
					navigator.sendBeacon(
						'/board_access',
						new Blob(
							[
								JSON.stringify({
									image_id: map.image_id,
									board_id: '{{board.board_id}}',
									board_method: 'toggle_map_visibility',
								}),
							],
							{ type: 'application/json' }
						)
					);
				};

				wrapper.appendChild(button);
				wrapper.appendChild(trashBtn);
				li.appendChild(wrapper);
				map_select.appendChild(li);
				return li;
			});
			
		}

		function build_map_select() {

			map_select.innerHTML = "";
			let promises = [];
			for (let i = 0; i < maps.length; i++) {
				if (maps[i].editable == false) continue;
				
				promises.push(build_map_select_li(maps[i]));				
			}

			new Sortable(document.getElementById('map-select'), {
				animation: 150,
				ghostClass: 'sortable-ghost',
				handle: 'button', // so users drag by clicking the button area
				onEnd: function (evt) {
					map_order = Array.from(document.querySelectorAll('#map-select img')).map(img => img.getAttribute('name').slice(4));
					// reorder maps for no refresh flash
					maps.sort((a, b) => map_order.indexOf(a.image_id) - map_order.indexOf(b.image_id));
					navigator.sendBeacon(
						'/board_access',
						new Blob(
							[JSON.stringify({
								'board_method': 'reorder_maps',
								'board_id': '{{board.board_id}}',
								'order': map_order
							})],
							{type: 'application/json'}
						)
					);
				}
			});

			return Promise.all(promises);
		}


		function set_keybindings() {
			let token_keybindings = document.getElementById('token-keybindings');
			token_keybindings.innerHTML = "";
			let keys = [];
			for (let token_id in icons['token']) {
				if (icons['token'][token_id].key) {
					const tr = document.createElement('tr');
					tr.setAttribute('id', 'key-bind-token-' + token_id);
					const th = document.createElement('th');
					th.appendChild(icon_images['token'][token_id].cloneNode(true));
					th.appendChild(document.createTextNode(icons['token'][token_id].name));
					tr.appendChild(th);
					const td = document.createElement('td');
					td.innerText = 'Shift + ' + icons['token'][token_id].key;
					if (keys.includes(icons['token'][token_id].key)) {
						const warning = document.createElement('i');
						warning.className = 'bi bi-exclamation-triangle-fill text-warning';
						td.append(warning);
					}
					keys.push(icons['token'][token_id].key);
					tr.appendChild(td);
					token_keybindings.appendChild(tr);
				}
			}
		}


		async function initialize() {
			try {
				loading(true, 'Creating images')
				await create_DOMs(); // Wait for all images to load

				// // Ensure all DOM updates are done
				// await new Promise(resolve => setTimeout(resolve, 100)); // 100ms delay to let the browser render images
				loading(true, 'Building menus')
				await build_menu();
				order_menu();
				loading(true, 'Building maps')
				await build_map_select();
				loading(true, 'Setting Keybindings')
				set_keybindings();
				loading(true, 'Painting display')
				update_display();
				
			} catch (error) {
				console.error('Error loading images:', error);
			} finally {
				loading(false); // Call loading(false) after everything is rendered
			}
		}

		window.onload = function() {
			let rect = canvas.getBoundingClientRect();
			canvas.width = rect.width;
			canvas.height = rect.height;

			num_squares = JSON.parse('{{ num_squares|tojson }}');

			
			if (localStorage.hasOwnProperty('zoom+{{ board.board_id }}')) {
				zoom = JSON.parse(localStorage.getItem('zoom+{{ board.board_id }}'));
				square_size = zoom * canvas.width / num_squares.x;
			} else {
				square_size = Math.min(canvas.width / num_squares.x, canvas.height / num_squares.y) / 1.2;
				zoom = num_squares.x * square_size / canvas.width;
			}

			set_zoom(zoom);

			
			if (localStorage.hasOwnProperty('top_left_loc+{{ board.board_id }}')) {
				top_left_loc = JSON.parse(localStorage.getItem('top_left_loc+{{ board.board_id }}'));
			} else {
				set_top_left(
					(canvas.width - num_squares.x * square_size) / 2,
					(canvas.height - num_squares.y * square_size) / 2,
				);
			}

			initialize();

			

			var socket = io({transports: ['websocket']});
	
			socket.on('connect', function() {
				console.log('connected to socketIO');
				socket.emit('join', { board_id: '{{ board.board_id}}' });
			});
			socket.on('disconnect', function() {
				console.log('disconnected from socketIO');
			});
			socket.on('connect_error', function(err) {
				console.log('socket: connect error');
				console.log(err);
			});
			socket.on('connect_timeout', function(err) {
				console.log('socket: connect timeout');
				console.log(err);
			});
			socket.on('reconnect', function() {
				console.log('socket: reconnected');
			});
			socket.on('reconnect_attempt', function() {
				console.log('socket: reconnect attempt');
			});
			socket.on('reconnect_error', function(err) {
				console.log('socket: reconnect error');
				console.log(err);
			});
			socket.on('reconnect_failed', function() {
				console.log('socket: reconnect failed');
			});	


			// changes
			socket.on('update icon', function(msg) {
				console.log('socket: update icon');
				document.querySelectorAll(`[data-id="${msg.type}-${msg.id}"]`).forEach(img => {
					img.src = `/${msg.type}/${msg.id}?t=${new Date().getTime()}`
				});
				make_icon_DOM(msg.type, msg.id).then(function() {
					update_display();
				});
			});

			socket.on('rebuild map select', function(msg) {
				console.log('socket: rebuild map select');
				loading(true, 'Building maps');
				if (!areMapsEqual(msg.maps, maps)) {
					maps = msg.maps;
					build_map_select().then(() => {
						update_display();
						loading(false);
					});
				} else {
					update_display();
					loading(false);
				}
				
			});

			socket.on('new map', function(msg) {
				console.log('socket: new map');
				loading(true, 'Building map');
				let promises = [];
				if (can_edit || !super_secret) {
					maps.push(msg.map);
					promises.push(make_map_DOM(msg.map).then(() => build_map_select_li(msg.map)));
				} else {
					promises.push(set_visible_map_image());
				}
				
				Promise.all(promises).then(() => {
					update_display();
					loading(false);
				});
			
			});

			socket.on('toggle visibility', function(msg) {
				console.log('socket: toggle visibility');
				loading(true, 'Changing map visibility');
				if (can_edit || !super_secret) {
					let eye = document.getElementById('map-eye-icon-' + msg.image_id);
					eye.style.visibility = eye.style.visibility == 'hidden' ? 'visible' : 'hidden';  
					for (let i = 0; i < maps.length; i++) {
						if (maps[i].image_id == msg.image_id) {
							maps[i].visible = !maps[i].visible;
							break;
						}
					}
					update_display();
					loading(false);
				} else {
					loading(true, 'Building map');
					set_visible_map_image().then(() => {
						update_display();
						loading(false);
					});
				}
			});

			socket.on('update squares', function(msg) {
				console.log('socket: update squares');
				for (let change of msg.changes) {
					board[change[0].r][change[0].c] = change[1];
				}
				if (msg.mask_change && super_secret) {
					set_visible_map_image().then(() => {
						update_display();
						loading(false);
					});
				} else {
					update_display();
					loading(false);
				}
				
				update_aura_menu();
				
			});

			socket.on('update grid data', function(msg) {
				console.log('socket: update grid data');
				loading(true, 'Updating grid');
				board = msg.board;
				num_squares = {
					x: board[0].length,
					y: board.length
				};
				zoom = num_squares.x * square_size / canvas.width;
				set_zoom(zoom);
				if (selected_square && (selected_square['c'] >= num_squares.x || selected_square['r'] >= num_squares.y)) {
					set_selected_square(null);
					close_menu();
				}
				update_display();
				
				loading(false);
			});

			socket.on('update keybindings', function(msg) {
				
				icons['token'][msg.id] = msg.token;
				set_keybindings();

				// console.log('socket: update keybindings');
				// icons['token'][msg.id] = msg.token;
				// let tr = document.getElementById('key-bind-token-' + msg.id);
				// console.log(tr)
				// if (tr == null) {
				// 	tr = document.createElement('tr');
				// 	document.getElementById('token-keybindings').appendChild(tr);
				// }
				// tr.innerHTML = "";
				// if (icons['token'][msg.id].key) {
				// 	fill_key_bind_tr(tr, msg.id);
				// }

			});
			
			socket.on('update token size', function(msg) {
				console.log('socket: update token size');
				icons['token'][msg.id] = msg.token;
				update_display();
			});

			socket.on('new token', function(msg) {
				console.log('socket: new token');
				loading(true, 'Building new token');
				icons['token'][msg.id] = msg.token;
				set_keybindings();
				make_icon_DOM('token', msg.id)
					.then(() => build_menu_item('token', msg.id))
					.then(() => {
						update_display();
						order_menu();
						loading(false);
					});
				});
			


			socket.on('delete map', function(msg) {
				console.log('socketio: delete map');
				loading(true, 'Deleting map')
				
				if (super_secret) {
					set_visible_map_image()
						.then(() => {
							update_display();
							loading(false);
							console.log("here2")

						});
				} else {
					maps = maps.filter(map => map.image_id != msg.image_id);
					if (can_edit) {
						document.getElementById('map-select-li-' + msg.image_id).remove();
						delete map_images[msg.image_id];
					}
					update_display();
					loading(false);
			
				}

			});

			socket.on('user joined', function(msg) {
				console.log('socketio: user joined');
				loading(true, 'Adding new user');
				let promises = [];
				// add tokens
				for (let token_id in msg.tokens) {
					icons['token'][token_id] = msg.tokens[token_id];
					make_icon_DOM('token', token_id);
					promises.push(build_menu_item('token', token_id));
				}
				
				// set avatar image
				icons['avatar'][msg.user_id] = {'name': msg.name};
				make_icon_DOM('avatar', msg.user_id);
				promises.push(build_menu_item('avatar', msg.user_id));
				
				Promise.all(promises).then(() => {
					set_keybindings();
					order_menu();
					loading(false);
				});				
				
			})

			socket.on('set users can edit', function(msg) {
				console.log('socketio: set users can edit');
				loading(true, 'Updating user permissions')
				can_edit = msg.users_can_edit;
				document.getElementById('map-controls').hidden = !can_edit;
				document.getElementById('mask-info-tr').hidden = !can_edit;
				maps = msg.maps;

				if (can_edit) {
					create_DOMs().then(() => {
						update_display();
						loading(false);
					});
				} else {
					map_images = {};
					loading(false);
				}
			});


			socket.on('set super secret', function(msg) {
				console.log('socketio: set super secret');
				loading(true, 'Reconfiguring permissions')
				super_secret = msg.super_secret;
				maps = msg.maps;
				if (can_edit || !super_secret) {
					create_DOMs().then(() => {
						update_display();
						loading(false);
					});
				}
				if (super_secret) {
					loading(true, 'Building map');
					board = msg.grid_data;
					set_visible_map_image().then(() => {
						update_display();
						loading(false);
					});
					map_images = {};
				}
			});

			socket.on('set grid_offset', function(msg) {
				console.log('socket: set grid_offset');
				Array.from(document.getElementById('offset-dropdown').children).forEach(option => option.selected = false);
				document.getElementById('offset-dropdown-' + msg.offset.type).selected = true;
				document.getElementById('offset-amount-slider').value = msg.offset.amount;
				grid_offset = msg.offset;
				update_display();

			});


		};

		function areMapsEqual(a, b) {
			return a.length === b.length && a.every((obj, i) => {
				const other = b[i];
				return Object.keys(obj).every(k => obj[k] === other[k]);
			});
		}




		function local_change_offset_amount(amount) {
			grid_offset.amount = Number(amount);
			update_display();
		}








		const upload_map_form = document.getElementById('upload_map_form');
		upload_map_form.addEventListener('submit', async (e) => {
			e.preventDefault();
			const upload_map_file = document.getElementById('upload-map-file');
			const upload_map_name = document.getElementById('upload-map-name');
			const file = upload_map_file.files[0];
			var confirmed = true;
			console.log(file.size);
			if (file && file.size > Math.pow(2, 20)) {
				confirmed = confirm("The file size is large and might slow performance. Consider lowering image quality. Click 'Cancel' to cancel and 'Ok' to proceed anyway.");
			}
			
			if (!confirmed) return;

			loading(true, "Uploading new map");

			try {
				const res = await fetch('/board_access', {
					method: 'POST',
					body: new FormData(upload_map_form)
				});
				loading(true, "Processing image")

				const message = await res.text();

				if (res.ok) {
					upload_map_file.value = '';
					upload_map_name.value = '';
				} else {
					alert(message);
				}
			} catch (err) {
				console.error('Upload failed:', err);
				alert('An error occurred during upload.');
			}
		});


		function reset() {
			navigator.sendBeacon(
				'/board_access',
				new Blob(
					[JSON.stringify({
						'board_id': '{{board.board_id}}',
						'board_method': 'reset'
					})],
					{type: 'application/json'}
				)
			);
		}

		function change_num_squares(ax, num) {
			loading(true, 'Changing number of squares');
			navigator.sendBeacon(
				'/board_access',
				new Blob(
					[JSON.stringify({
						'board_method': 'change_num_squares',
						'board_id': '{{board.board_id}}',
						'axis': ax,
						'num': num
					})],
					{type: 'application/json'}
				)
			);
		}

		function set_square(square, data) {
			close_menu();
			navigator.sendBeacon(
				'/board_access',
				new Blob([JSON.stringify({
					'board_method': 'set_square',
					'board_id': "{{board.board_id}}",
					'square': square,
					'data': data
				})], { type: 'application/json' })
			);
		}

		function toggle_mask(square) {
			navigator.sendBeacon(
				'/board_access',
				new Blob([JSON.stringify({
					'board_method': 'toggle_mask_square',
					'board_id': "{{board.board_id}}",
					'square': square
				})], { type: 'application/json' })
			);
		}

		function change_grid_offset(offset) {
			navigator.sendBeacon(
				'/board_access',
				new Blob([JSON.stringify({
					'board_method': 'set_grid_offset',
					'board_id': "{{board.board_id}}",
					'offset': offset
				})], { type: 'application/json' })
			);
		}

		function change_grid_offset_amount(amount) {
			navigator.sendBeacon(
				'/board_access',
				new Blob([JSON.stringify({
					'board_method': 'set_grid_offset_amount',
					'board_id': "{{board.board_id}}",
					'amount': amount
				})], { type: 'application/json' })
			);
		}

		function update_aura() {
			let enabled = document.getElementById('aura-toggle').checked || false; // make these defaults variables
			let color = document.getElementById('aura-color').value || '#ffff00';
			let size = document.getElementById('aura-size').value || 1;
			let shape = document.getElementById('aura-shape').value
		
			navigator.sendBeacon(
				'/board_access',
				new Blob([JSON.stringify({
					'board_method': 'update_aura',
					'board_id': "{{board.board_id}}",
					'aura': {
						'enabled': enabled,
						'color': color,
						'size': size,
						'shape': shape
					},
					'square': selected_square
				})], { type: 'application/json' })
			);

		}


		// function toggle_unique(bool) {
		// 	navigator.sendBeacon(
		// 		'/board_access',
		// 		new Blob([JSON.stringify({
		// 			'board_method': 'toggle_unique',
		// 			'board_id': "{{board.board_id}}",
		// 			'square': selected_square
		// 		})], { type: 'application/json' })
		// 	);
		// }



		// function leave() {
		// 	navigator.sendBeacon("/leave");
		// }














		function gcd(a, b) {
			if (!b) {
				return Math.abs(a);
			}
			return gcd(b, a % b);
		}

		function box_counting_metric(x, y) {
			let count = 0;
			for (a = 0; a < x; a++) {
				for (b = 0; b < y; b++) {
					if (y / x === (2 * a - 1)/(2 * b - 1)) {
						count++;
					}
				}
			}
			return x + y - count;
		}


		function get_square_loc(r, c) {
			return {
				x: top_left_loc.x + c * square_size + (grid_offset.type=='Rows' && r % 2 == 0 ? square_size * grid_offset.amount : 0),
				y: top_left_loc.y + r * square_size + (grid_offset.type=='Columns' && c % 2 == 0 ? square_size * grid_offset.amount : 0)
			};
		}


		function update_display() {
			const LINE_WIDTH = 1;


			// clear the display
			// ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			// table color
			ctx.fillStyle = colors.table;
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			// background color
			ctx.fillStyle = colors.background;
			ctx.fillRect(
				top_left_loc.x,
				top_left_loc.y,
				square_size * num_squares.x,
				square_size * num_squares.y
			);

			// maps
			ctx.globalAlpha = map_opacity;
			let map_height = square_size * num_squares.y;
			let map_width = square_size * num_squares.x;
			if (super_secret) {
				ctx.drawImage(
					visible_map_image,
					top_left_loc.x,
					top_left_loc.y,
					map_width,
					map_height
				);
			} else {
				for (let i = maps.length - 1; i >= 0; i--) {
					if (maps[i].visible) {
						ctx.drawImage(
							map_images[maps[i].image_id],
							top_left_loc.x,
							top_left_loc.y,
							map_width,
							map_height
						);
					}
				}
			}
		
			ctx.globalAlpha = 1; 






			// fill squares
			let TYPES = ['token', 'avatar']; // this is the order they are displayed
			for (let type of TYPES) {
				for (let i = 0; i < num_squares.y; i++) {
					for (let j = 0; j < num_squares.x; j++) {
						// if (grid_offset == 'Rows' && i % 2 == 0 && j == num_squares.x - 1) continue;
						// if (grid_offset == 'Columns' && j % 2 == 0 && i == num_squares.y - 1) continue;
						let sq = get_square_loc(i, j);						
						if (board[i][j].content) {	
							if (board[i][j].content.type == 'token') {
								let img = icon_images[board[i][j].content.type][board[i][j].content.id];
								let size = icons[board[i][j].content.type][board[i][j].content.id].size;
								// size *= board[i][j].content.size || 1;
								if (img?.complete) {
									ctx.drawImage(
										img,
										sq.x - square_size * (size - 1) / 2,
										sq.y - square_size * (size - 1) / 2,
										square_size * size,
										square_size * size
									);
								}
							}
							else if (board[i][j].content.type == "avatar") {
								let img = icon_images[board[i][j].content.type][board[i][j].content.id];
								if (img?.complete) {
									const centerX = sq.x + square_size / 2;
									const centerY = sq.y + square_size / 2;
									const radius = square_size / 2 - square_size / 10;

									ctx.save();
									ctx.beginPath();
									ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
									ctx.closePath();
									ctx.clip(); // Set the clip to the circular path

									ctx.drawImage(
										img,
										sq.x + square_size / 10,
										sq.y + square_size / 10,
										square_size * 0.8,
										square_size * 0.8
									);

									ctx.restore();
								}
							}
						}
						
					}
				}
			}




			// auras
			ctx.globalAlpha = 0.25;
			for (let i = 0; i < num_squares.y; i++) {
				for (let j = 0; j < num_squares.x; j++) {
					if (board[i][j].mask) continue;

					if (board[i][j].content && board[i][j].content.aura && board[i][j].content.aura.enabled) {
						ctx.fillStyle = board[i][j].content.aura.color;
						let sq = get_square_loc(i, j);
						if (board[i][j].content.aura.shape == 'square') {
							ctx.fillRect(
								sq.x - square_size * (board[i][j].content.aura.size),
								sq.y - square_size * (board[i][j].content.aura.size),
								square_size * (board[i][j].content.aura.size * 2 + 1),
								square_size * (board[i][j].content.aura.size * 2 + 1)
							);
						} else if (board[i][j].content.aura.shape == 'circle') {
							ctx.beginPath();
							ctx.arc(
								sq.x + square_size / 2,
								sq.y + square_size / 2,
								(board[i][j].content.aura.size) * square_size,
								0,
								Math.PI * 2
							);
							ctx.fill();
						} else if (board[i][j].content.aura.shape == 'diamond') {
							ctx.beginPath();
							ctx.moveTo(sq.x + square_size / 2, sq.y - (board[i][j].content.aura.size - 0.5) * square_size); // Top
							ctx.lineTo(sq.x + square_size + (board[i][j].content.aura.size - 0.5) * square_size, sq.y + square_size / 2); // Right
							ctx.lineTo(sq.x + square_size / 2, sq.y + square_size + (board[i][j].content.aura.size - 0.5) * square_size); // Bottom
							ctx.lineTo(sq.x - (board[i][j].content.aura.size - 0.5) * square_size, sq.y + square_size / 2); // Left
							ctx.closePath();
							ctx.fill();
						}
						
						
					}

				}
			}
			ctx.globalAlpha = 1; // Reset opacity





			// fill masks
			for (let type of TYPES) {
				for (let i = 0; i < num_squares.y; i++) {
					for (let j = 0; j < num_squares.x; j++) {
						let sq = get_square_loc(i, j);						
						if (board[i][j].mask) {
							ctx.fillStyle = colors.mask;
							ctx.globalAlpha = colors.maskOpacity;
							ctx.fillRect(sq.x, sq.y, square_size, square_size);
							ctx.globalAlpha = 1;
						}
					}
				}
			}



			// add the grid lines
			for (let i = 0; i < num_squares.y; i++) {
				for (let j = 0; j < num_squares.x; j++) {
					// if (grid_offset == 'Rows' && i % 2 == 0 && j == num_squares.x - 1) continue;
					// if (grid_offset == 'Columns' && j % 2 == 0 && i == num_squares.y - 1) continue;
					ctx.strokeStyle = colors.grid;
					ctx.lineWidth = 1;
					let sq = get_square_loc(i, j);
					ctx.beginPath();
					ctx.rect(sq.x, sq.y, square_size, square_size);
					ctx.stroke();
				}
			}


			// draw selected square
			if (selected_square) {
				ctx.lineWidth = 5;
				ctx.strokeStyle = colors.selection;
				let sq = get_square_loc(selected_square.r, selected_square.c);
				ctx.beginPath();
				ctx.rect(sq.x, sq.y, square_size, square_size);
				ctx.stroke();

				if (distance_metric != 'none') {
				
					// Find the user's avatar position
					let userAvatarPosition = null;
					for (let i = 0; i < num_squares.y; i++) {
						for (let j = 0; j < num_squares.x; j++) {
							if (board[i][j].content && board[i][j].content.type === 'avatar' && board[i][j].content.id === '{{user.user_id}}') {
								userAvatarPosition = { r: i, c: j };
								break;
							}
						}
						if (userAvatarPosition) break;
					}

					// If the user's avatar is placed, calculate the distance
					if (userAvatarPosition) {
						let diffX = selected_square.c - userAvatarPosition.c;
						let diffY = selected_square.r - userAvatarPosition.r;

						if (grid_offset == 'Rows') {
							if ((selected_square.r - userAvatarPosition.r) % 2 != 0) {
								diffX -= 0.5;
							}
						}
						if (grid_offset == 'Columns') {
							if ((selected_square.c - userAvatarPosition.c) % 2 != 0) {
								diffY -= 0.5;
							}
						}

						diffX = Math.abs(diffX);
						diffY = Math.abs(diffY);

						// console.log(diffX, diffY);

						let dist;
						if (distance_metric === 'L1') {
							dist = diffX + diffY;
						} else if (distance_metric === 'L2') {
							dist = Math.hypot(diffX, diffY);
						} else if (distance_metric === 'Li') {
							dist = Math.max(diffX, diffY);
						} else if (distance_metric == 'box') {
							dist = box_counting_metric(diffX, diffY);
						}

						dist *= distance_multiplier;
						// Draw the distance indicator
						ctx.fillStyle = colors['selection'];
						ctx.font = `20px Arial`;
						ctx.textAlign = "center";
						ctx.textBaseline = "bottom";
						ctx.fillText(
							dist.toFixed(2),
							sq.x + square_size / 2,
							sq.y - square_size / 20
						);
					}
				}
			}

		

		}

		


	</script>

</html>
